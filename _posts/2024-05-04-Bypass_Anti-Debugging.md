---
title: Bypass Anti-Debugging
categories: Tips-Reversing
comment: true
---

### Linux - ptrace

Linux에서 가장 흔하게 볼 수 있는 안티 디버깅 트릭이다.

```nasm
ptrace();
```

원래는 디버깅 목적으로 만들어진 함수이지만, anti-reversing을 위한 목적으로도 빈번하게 사용되고 있다. 이는 본인 스스로를 디버깅하는 형태의 코드로 많이 사용된다.

대부분의 OS는 프로세스 하나 당 최대 한 개의 디버거만 부착되도록 하고 있다. 이를 이용하여 본인에게 디버깅을 시도해 봄으로써 다른 디버거가 부착되어 있는지 여부를 판단하게 된다.

일반적으로 디버거가 부착되지 않은 실제 실행 환경에서는 ptrace가 정상적으로 작동한다. 그렇기에 ptrace는 0을 반환. 반면, 디버거가 부착된 디버깅 환경에서는 ptrace 함수가 실패하게 되면서 -1을 반환하게 된다.

ptrace의 리턴값이 실제 환경과 디버깅 환경에서 다르다는 점을 이용하여서 디버깅 환경에서 실제 환경과 다른 동작을 하도록 한다던가, 디버깅 중이라 판단되면 exit()으로 바로 프로세스를 종료한다던가 등으로 안티 디버깅이 구현되어 있다.

만약 자기 자신을 디버깅하는 `ptrace`가 여러 번 호출된다면??

실제 환경에서는 첫 번째로 실행되는 ptrace만 정상적으로 작동하고 두 번째부터는 이미 본인이 trace process로 붙어 있기 때문에 실패하게 된다. 물론 real world에서 이따구로 코딩해 놓은 경우가 있을까 싶긴 하다…

이런 형태의 안티 디버깅을 조금 더 발전시키면 ptrace가 anti-debugging 그 이상으로 사용되게 하는 것이다. 실제 디버깅을 수행함으로써 바이너리 내부 로직에 유의미한 영향을 끼치게 만들면 단순히 ptrace 전체를 무력화하는 방법으로는 우회하기가 어렵게 된다.

**우회 방법**

가장 편리한 방법으로는 ptrace를 호출하지 않도록 패치하면 된다. 혹은 디버거에서 ptrace의 리턴 값을 0으로 강제로 설정해주면 된다.

gdb에서 값 설정하기

```nasm
gdb) set $rax = 0
```

IDA에서 값 설정하기

rax에 커서를 갖다 댄 뒤, 우클릭 후 Edit으로 값을 0으로 변경

만약 ptrace가 단순 anti-debugging 트릭이 아닌 실제로 유의미한 작업을 하고 있다면 단순 ptrace를 호출하지 않도록 패치하면 문제가 생길 수 있다. 디버거에서 리턴 값을 0으로 설정해 주면 된다.

ptrace 같은 경우에는 마구마구 덕지덕지 붙여 놓을 수 있는 안티 디버깅은 아니다. 한 번밖에 사용이 안되기 때문. 그렇기 때문에 일반적으로 한 번만 우회하면 그 뒤에는 딱히 신경 쓸 필요는 없다.

### Window - IsDebuggerPresent

Linux에서는 ptrace가 가장 흔했다면, 위 안티 디버깅 함수는 윈도우에서 가장 흔하게 볼 수 있는 안티 디버깅 트릭이다.

이 방법은 원리가 훨씬 간단한데, 윈도우에서 프로세스 관련 정보를 적어 놓은 PEB 영역에서 부착된 프로세스와 관련된 정보를 읽어와서 디버깅 여부를 판별한다.

우회 방법은 ptrace와 거의 유사하다. 대신 ptrace와 다르게 여기 저기 덕지덕지 발라 놓을 수 있는 안티 디버깅 방법이기 때문에 해당 함수가 여기저기 엄청 많이 쓰였다면 일일이 패치하기 보다는 dll injection 등을 통해 해당 함수가 실행되는 control flow를 hijacking하여 우회 루틴을 심어 놓는 방법 등이 유효하다.

### 유형 별 정리

Self-debugging 형식의 안티 디버깅, 프로세스의 상태를 읽어오는 형식의 안티 디버깅 외에도 여러 가지의 안티 디버깅 형식이 있을 수 있다. 대표적인 것들 몇 가지만 알아보자.

self-debugging 형식은 일반적으로 디버깅 용도의 함수들을 이용하여 구현된다. 라이브러리의 함수를 검색하다가 디버깅 관련 용도의 함수라면 안티 디버깅을 의심해볼 수 있다.

프로세스 상태를 읽어오는 경우에 Window는 PEB 영역을 직접 읽어오는 방법이 있고 Linux의 경우에는 `/proc/self/status` 를 읽어오면 여기서도 trace pid에 대한 정보를 얻을 수 있다.

무결성 검사. 무결성 검사는 본래의 디버거를 감지하기 위한 목적의 검사는 아니다. 하지만, 디버거가 중단점을 설정하는 과정에서 바이너리에 대한 패치를 수행하므로 무결성 검사가 이를 잡아낼 수 있다. 중단점을 설정할 때 Intel x64 기계어의 경우에 중단점을 설정하고 싶은 주소에 `0xCC` 기계어로 패치하면서 해당 기계어를 실행할 때 프로세스 실행을 멈추게 된다.

비슷한 원리의 안티 디버깅으로 `0xCC` 에 해당하는 기계어를 탐지하는 루틴을 삽입할 수도 있다.

시간 검증. 일반적인 디버깅 작업은 중단점을 설정하고 프로세스 상태를 확인하고 등의 작업을 수행함으로써 프로세스의 실행 시간을 비약적으로 증가시킨다. 이를 이용하여 프로세스가 실행되는데 걸린 시간을 검증함으로써 비정상적으로 긴 시간 동안 프로세스가 실행된 경우 디버거가 물려있다고 판단하는 형식의 안티 디버깅 트릭이다. 구현하기 쉬운 방법인 만큼 허점이 좀 많은 방법이다. 디버거를 잘못 탐지할 가능성이 상당히 존재하며, 우회하기도 쉽다. 일반적으로 패치를 통해 쉽게 우회할 수 있으며, 스크립트를 통해 디버깅을 자동화한다면 시간 검증이 이를 잡아내지 못할 수도 있다.

OS의 도움을 받아 현재 실행 중인 프로세스 중에 디버거가 있는지 검색하는 방법이 있다. 일반적으로 잘 알려진 디버깅 툴을 사용하여 디버깅하므로 window라면 ollydbg, windbg, x64dbg 등의 프로세스가 실행되고 있는지, Linux라면 gdb 등의 디버거 프로세스가 실행되고 있는지 검색하는 방법이다. 바이너리 내부에서 디버거 이름이 발견된다면 이러한 종류의 안티 디버깅을 의심해 볼 수 있을 것 같다.